name: iOS Build & Deploy

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]
  workflow_dispatch:
    inputs:
      deploy_to_appstore:
        description: 'Deploy to App Store'
        required: false
        default: false
        type: boolean

jobs:
  build:
    name: iOS Build & Version
    runs-on: macos-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Early secrets validation
      run: |
        echo "üîç Early validation of required secrets..."
        echo "üìã This step runs early to catch issues before the build starts"
        
        # Check which secrets are set (without revealing values)
        SECRETS_STATUS=""
        
        if [ -n "${{ secrets.APPLE_DEVELOPER_CERTIFICATE }}" ]; then
          SECRETS_STATUS="$SECRETS_STATUS‚úÖ APPLE_DEVELOPER_CERTIFICATE is set\n"
        else
          SECRETS_STATUS="$SECRETS_STATUS‚ùå APPLE_DEVELOPER_CERTIFICATE is NOT set\n"
        fi
        
        if [ -n "${{ secrets.APPLE_DEVELOPER_CERTIFICATE_PASSWORD }}" ]; then
          SECRETS_STATUS="$SECRETS_STATUS‚úÖ APPLE_DEVELOPER_CERTIFICATE_PASSWORD is set\n"
        else
          SECRETS_STATUS="$SECRETS_STATUS‚ùå APPLE_DEVELOPER_CERTIFICATE_PASSWORD is NOT set\n"
        fi
        
        if [ -n "${{ secrets.APPLE_PROVISIONING_PROFILE }}" ]; then
          SECRETS_STATUS="$SECRETS_STATUS‚úÖ APPLE_PROVISIONING_PROFILE is set\n"
        else
          SECRETS_STATUS="$SECRETS_STATUS‚ùå APPLE_PROVISIONING_PROFILE is NOT set\n"
        fi
        
        if [ -n "${{ secrets.APPLE_TEAM_ID }}" ]; then
          SECRETS_STATUS="$SECRETS_STATUS‚úÖ APPLE_TEAM_ID is set\n"
        else
          SECRETS_STATUS="$SECRETS_STATUS‚ùå APPLE_TEAM_ID is NOT set\n"
        fi
        
        if [ -n "${{ secrets.APPLE_BUNDLE_ID }}" ]; then
          SECRETS_STATUS="$SECRETS_STATUS‚úÖ APPLE_BUNDLE_ID is set\n"
        else
          SECRETS_STATUS="$SECRETS_STATUS‚ùå APPLE_BUNDLE_ID is NOT set\n"
        fi
        
        if [ -n "${{ secrets.APPLE_PROVISIONING_PROFILE_NAME }}" ]; then
          SECRETS_STATUS="$SECRETS_STATUS‚úÖ APPLE_PROVISIONING_PROFILE_NAME is set\n"
        else
          SECRETS_STATUS="$SECRETS_STATUS‚ùå APPLE_PROVISIONING_PROFILE_NAME is NOT set\n"
        fi
        
        echo -e "üìã Secrets Status:\n$SECRETS_STATUS"
        
        # Check if we have the minimum required secrets
        if [ -z "${{ secrets.APPLE_DEVELOPER_CERTIFICATE }}" ] || [ -z "${{ secrets.APPLE_DEVELOPER_CERTIFICATE_PASSWORD }}" ] || [ -z "${{ secrets.APPLE_PROVISIONING_PROFILE }}" ]; then
          echo "‚ùå Missing required secrets for code signing"
          echo "üìù To fix this, you need to:"
          echo "1. Export your iOS Distribution certificate from Keychain Access"
          echo "2. Base64 encode it: base64 -i certificate.p12 | pbcopy"
          echo "3. Add it as APPLE_DEVELOPER_CERTIFICATE secret in GitHub"
          echo "4. Add the certificate password as APPLE_DEVELOPER_CERTIFICATE_PASSWORD"
          echo "5. Export your App Store provisioning profile"
          echo "6. Base64 encode it: base64 -i profile.mobileprovision | pbcopy"
          echo "7. Add it as APPLE_PROVISIONING_PROFILE secret in GitHub"
          exit 1
        fi
        
        echo "‚úÖ All required secrets are present"
        
    - name: Early base64 validation
      run: |
        echo "üîç Early base64 validation of secrets..."
        
        # Test certificate secret
        if [ -n "${{ secrets.APPLE_DEVELOPER_CERTIFICATE }}" ]; then
          echo "üìã Certificate secret is set"
          
          # Test base64 decode and check if it produces valid output
          CERT_DECODED=$(echo "${{ secrets.APPLE_DEVELOPER_CERTIFICATE }}" | base64 --decode 2>/dev/null)
          if [ $? -eq 0 ] && [ -n "$CERT_DECODED" ]; then
            echo "‚úÖ Certificate secret base64 decode test: PASSED"
            echo "üìã Decoded certificate size: $(echo "$CERT_DECODED" | wc -c) bytes"
          else
            echo "‚ùå Certificate secret base64 decode test: FAILED"
            echo "üìã This suggests the secret might not be properly base64 encoded"
            exit 1
          fi
        else
          echo "‚ùå Certificate secret is NOT set"
          exit 1
        fi
        
        # Test profile secret
        if [ -n "${{ secrets.APPLE_PROVISIONING_PROFILE }}" ]; then
          echo "üìã Profile secret is set"
          
          # Test base64 decode and check if it produces valid output
          PROFILE_DECODED=$(echo "${{ secrets.APPLE_PROVISIONING_PROFILE }}" | base64 --decode 2>/dev/null)
          if [ $? -eq 0 ] && [ -n "$PROFILE_DECODED" ]; then
            echo "‚úÖ Profile secret base64 decode test: PASSED"
            echo "üìã Decoded profile size: $(echo "$PROFILE_DECODED" | wc -c) bytes"
          else
            echo "‚ùå Profile secret base64 decode test: FAILED"
            echo "üìã This suggests the secret might not be properly base64 encoded"
            exit 1
          fi
        else
          echo "‚ùå Profile secret is NOT set"
          exit 1
        fi
        
        echo "‚úÖ All base64 validation tests passed"
        
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        cache-dependency-path: react-native/package-lock.json
        
    - name: Setup Ruby
      uses: ruby/setup-ruby@v1
      with:
        ruby-version: '3.1'
        bundler-cache: true
        
    - name: Generate version
      id: version
      run: |
        # Get the latest build number from existing tags (check both v2.0.n and 2.0.n formats)
        LATEST_BUILD_V=$(git tag | grep '^v2\.0\.' | sort -V | tail -n 1 | sed 's/^v2\.0\.//' || echo "0")
        LATEST_BUILD_NO_V=$(git tag | grep '^2\.0\.' | sort -V | tail -n 1 | sed 's/^2\.0\.//' || echo "0")
        
        # Find the highest build number between the two formats
        if [ "$LATEST_BUILD_V" -gt "$LATEST_BUILD_NO_V" ]; then
          LATEST_BUILD=$LATEST_BUILD_V
        else
          LATEST_BUILD=$LATEST_BUILD_NO_V
        fi
        
        # Start with 2.0.1 if no previous 2.0.x tags exist
        if [ "$LATEST_BUILD" -eq 0 ]; then
          LATEST_BUILD=0
          echo "üìã Starting new 2.0.x version series"
        fi
        
        # Increment build number
        NEW_BUILD=$((LATEST_BUILD + 1))
        
        # Generate version: 2.0.BUILD_NUMBER
        VERSION="2.0.${NEW_BUILD}"
        
        echo "Latest build number from v2.0.n tags: $LATEST_BUILD_V"
        echo "Latest build number from 2.0.n tags: $LATEST_BUILD_NO_V"
        echo "Using highest build number: $LATEST_BUILD"
        echo "New build number: $NEW_BUILD"
        echo "Generated version: $VERSION"
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "build_number=$NEW_BUILD" >> $GITHUB_OUTPUT
        
    - name: Update version in app.json
      working-directory: ./react-native
      run: |
        VERSION="${{ steps.version.outputs.version }}"
        
        # Update version in app.json
        node -e "
          const fs = require('fs');
          const appJson = JSON.parse(fs.readFileSync('app.json', 'utf8'));
          appJson.version = '$VERSION';
          fs.writeFileSync('app.json', JSON.stringify(appJson, null, 2));
        "
        
    - name: Update build number in Xcode project
      working-directory: ./react-native/ios
      run: |
        VERSION="${{ steps.version.outputs.version }}"
        BUILD_NUMBER="${{ steps.version.outputs.build_number }}"
        
        echo "üì± Updating version to $VERSION in Xcode project..."
        
        # Update CURRENT_PROJECT_VERSION to use the full version string (not just build number)
        # This ensures Apple sees the correct version like "2.0.1" instead of just "1"
        sed -i '' "s/CURRENT_PROJECT_VERSION = [0-9.]*;/CURRENT_PROJECT_VERSION = $VERSION;/g" Guras.xcodeproj/project.pbxproj
        
        # Also update MARKETING_VERSION to match
        sed -i '' "s/MARKETING_VERSION = [0-9.]*;/MARKETING_VERSION = $VERSION;/g" Guras.xcodeproj/project.pbxproj
        
        # Verify the changes
        echo "üìã Updated version in Xcode project:"
        grep "CURRENT_PROJECT_VERSION" Guras.xcodeproj/project.pbxproj
        grep "MARKETING_VERSION" Guras.xcodeproj/project.pbxproj
        
    - name: Install dependencies
      working-directory: ./react-native
      run: |
        echo "üì¶ Installing dependencies for version ${{ steps.version.outputs.version }}"
        npm ci
        
    - name: Install iOS dependencies
      working-directory: ./react-native/ios
      run: |
        echo "üçé Installing iOS dependencies for version ${{ steps.version.outputs.version }}"
        pod install

    - name: Patch Hermes and RN scripts to use correct node path
      run: |
        echo "üîß Patching Node.js paths in shell scripts..."
        
        # Find and patch all shell scripts in Pods - use generic patterns
        find ./react-native/ios/Pods -type f -name '*.sh' -exec sed -i '' 's|/Users/.*/\.nvm/versions/node/.*/bin/node|node|g' {} +
        find ./react-native/ios/Pods -type f -name '*.sh' -exec sed -i '' 's|/Users/.*/\.nvm/versions/node/.*/bin/node|node|g' {} +
        
        # Also patch any hardcoded node paths in the main project
        find ./react-native/ios -type f -name '*.sh' -exec sed -i '' 's|/Users/.*/\.nvm/versions/node/.*/bin/node|node|g' {} +
        
        echo "‚úÖ Node.js paths patched in shell scripts"
        
        # Debug: Show which scripts were found and patched
        echo "üìã Found shell scripts in Pods:"
        find ./react-native/ios/Pods -type f -name '*.sh' | head -10
        
    - name: Disable Hermes for CI build
      working-directory: ./react-native/ios
      run: |
        echo "üö´ Disabling Hermes for CI build to avoid script issues"
        
        # Create a backup of the original Podfile
        cp Podfile Podfile.backup
        
        # Modify Podfile to exclude Hermes
        sed -i '' '/hermes-engine/d' Podfile
        
        echo "‚úÖ Hermes excluded from Podfile for CI build"
        
    - name: Reinstall iOS dependencies without Hermes
      working-directory: ./react-native/ios
      run: |
        echo "üçé Reinstalling iOS dependencies without Hermes for version ${{ steps.version.outputs.version }}"
        pod install

    - name: Setup Xcode
      uses: maxim-lobanov/setup-xcode@v1
      with:
        xcode-version: 'latest-stable'
        
    - name: Set NODE_BINARY environment variable
      run: |
        echo "üîß Setting NODE_BINARY environment variable"
        echo "NODE_BINARY=$(which node)" >> $GITHUB_ENV
        echo "NODE_BINARY set to: $(which node)"
        
    - name: Setup code signing
      run: |
        echo "üîê Setting up code signing for App Store deployment..."
        
        # Create keychain
        security create-keychain -p "" build.keychain
        security default-keychain -s build.keychain
        security unlock-keychain -p "" build.keychain
        security set-keychain-settings build.keychain
        
        # Import certificate
        echo "üìã Importing distribution certificate..."
        echo "${{ secrets.APPLE_DEVELOPER_CERTIFICATE }}" | base64 --decode > /tmp/certificate.p12
        
        # Check certificate file
        if [ ! -s /tmp/certificate.p12 ]; then
          echo "‚ùå Certificate file is empty or missing"
          exit 1
        fi
        
        # Import certificate into keychain
        security import /tmp/certificate.p12 -k build.keychain -P "${{ secrets.APPLE_DEVELOPER_CERTIFICATE_PASSWORD }}" -T /usr/bin/codesign
        security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "" build.keychain
        
        # Install provisioning profile
        echo "üìã Installing App Store provisioning profile..."
        echo "${{ secrets.APPLE_PROVISIONING_PROFILE }}" | base64 --decode > /tmp/profile.mobileprovision
        
        if [ ! -s /tmp/profile.mobileprovision ]; then
          echo "‚ùå Provisioning profile file is empty or missing"
          exit 1
        fi
        
        mkdir -p ~/Library/MobileDevice/Provisioning\ Profiles
        cp /tmp/profile.mobileprovision ~/Library/MobileDevice/Provisioning\ Profiles/
        
        # Get the actual profile name from the installed profile
        echo "üîç Detecting installed provisioning profile name..."
        PROFILE_NAME=$(security cms -D -i ~/Library/MobileDevice/Provisioning\ Profiles/*.mobileprovision | grep -A1 "<key>Name</key>" | tail -1 | sed 's/.*<string>\(.*\)<\/string>.*/\1/')
        
        if [ -z "$PROFILE_NAME" ]; then
          echo "‚ö†Ô∏è Could not detect profile name, using secret value..."
          PROFILE_NAME="${{ secrets.APPLE_PROVISIONING_PROFILE_NAME }}"
        fi
        
        echo "üìã Detected profile name: $PROFILE_NAME"
        
        # Verify certificate and profile
        echo "üîç Verifying code signing setup..."
        security find-identity -v -p codesigning build.keychain
        
        echo "‚úÖ Code signing setup completed"
        
    - name: Configure project for CI build
      working-directory: ./react-native/ios
      run: |
        echo "‚öôÔ∏è Configuring project for CI build"
        
        # Create a temporary build configuration that disables code signing
        # This is safer than modifying the project file directly
        echo "‚úÖ Project ready for CI build with code signing disabled"
        
    - name: Validate project structure
      working-directory: ./react-native/ios
      run: |
        echo "üîç Validating project structure for version ${{ steps.version.outputs.version }}"
        xcodebuild -workspace Guras.xcworkspace \
                   -scheme Guras \
                   -configuration Debug \
                   CODE_SIGN_IDENTITY="" \
                   CODE_SIGNING_REQUIRED=NO \
                   CODE_SIGNING_ALLOWED=NO \
                   NODE_BINARY="$NODE_BINARY" \
                   clean
        
    - name: Build JavaScript bundle
      working-directory: ./react-native
      run: |
        echo "üì± Building JavaScript bundle for version ${{ steps.version.outputs.version }}"
        npx react-native bundle --platform ios --dev false --entry-file index.js --bundle-output ios/main.jsbundle --assets-dest ios
        
    - name: Create Archive for Deployment
      working-directory: ./react-native/ios
      run: |
        echo "üì¶ Creating archive for version ${{ steps.version.outputs.version }}"
        xcodebuild -workspace Guras.xcworkspace \
                   -scheme Guras \
                   -configuration Release \
                   -destination generic/platform=iOS \
                   -archivePath ./build/Guras.xcarchive \
                   CODE_SIGN_IDENTITY="" \
                   CODE_SIGNING_REQUIRED=NO \
                   CODE_SIGNING_ALLOWED=NO \
                   NODE_BINARY="$NODE_BINARY" \
                   clean archive
                   
        echo "‚úÖ Archive created successfully"
        
    - name: Create and push tag
      if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'
      run: |
        VERSION="${{ steps.version.outputs.version }}"
        
        echo "üè∑Ô∏è Creating tag $VERSION"
        
        # Configure git
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        
        # Add and commit version changes
        git add react-native/app.json react-native/ios/Guras.xcodeproj/project.pbxproj
        git commit -m "Bump version to $VERSION" || echo "No changes to commit"
        
        # Create tag using version number directly
        git tag "$VERSION"
        
        # Push changes and tag
        git push origin master
        git push origin "$VERSION"
        
        echo "‚úÖ Created and pushed tag: $VERSION"
        
    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: ios-build-v${{ steps.version.outputs.version }}
        path: |
          react-native/ios/main.jsbundle
          react-native/app.json
          react-native/ios/Guras.xcodeproj/project.pbxproj
          react-native/ios/build/Guras.xcarchive
        retention-days: 7
        
    - name: Build Summary
      run: |
        echo "üéâ ========================================="
        echo "‚úÖ Build completed successfully!"
        echo "üì¶ Version: ${{ steps.version.outputs.version }}"
        echo "üè∑Ô∏è Tag: ${{ steps.version.outputs.version }}"
        echo "üì± Bundle: Available in artifacts"
        echo "üì¶ Archive: Available in artifacts"
        echo "üì¶ Artifact: ios-build-v${{ steps.version.outputs.version }}"
        echo "üéâ ========================================="

  deploy-testflight:
    name: Deploy to TestFlight
    runs-on: macos-latest
    needs: build
    if: success() && (github.event_name != 'workflow_dispatch' || github.event.inputs.deploy_to_appstore != 'true')
    
    steps:        
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Download build artifacts
      uses: actions/download-artifact@v4
      with:
        name: ios-build-v${{ needs.build.outputs.version }}
        path: ./artifacts
        
    - name: Setup Xcode
      uses: maxim-lobanov/setup-xcode@v1
      with:
        xcode-version: 'latest-stable'
        
    - name: Setup App Store Connect API
      run: |
        echo "üîê Setting up App Store Connect API for TestFlight deployment"
        
        # Create App Store Connect API key file
        echo "${{ secrets.APP_STORE_CONNECT_API_KEY }}" | base64 --decode > /tmp/AuthKey.p8
        
        # Set environment variables for App Store Connect API
        echo "APP_STORE_CONNECT_API_KEY_ID=${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}" >> $GITHUB_ENV
        echo "APP_STORE_CONNECT_ISSUER_ID=${{ secrets.APP_STORE_CONNECT_ISSUER_ID }}" >> $GITHUB_ENV
        echo "APP_STORE_CONNECT_API_KEY_PATH=/tmp/AuthKey.p8" >> $GITHUB_ENV
        
        echo "‚úÖ App Store Connect API configured"
        
    - name: Setup code signing for TestFlight
      run: |
        echo "üîê Setting up code signing for TestFlight deployment"
        
        # Check if secrets are available
        if [ -z "${{ secrets.APPLE_DEVELOPER_CERTIFICATE }}" ]; then
          echo "‚ùå APPLE_DEVELOPER_CERTIFICATE secret is not set"
          exit 1
        fi
        
        if [ -z "${{ secrets.APPLE_DEVELOPER_CERTIFICATE_PASSWORD }}" ]; then
          echo "‚ùå APPLE_DEVELOPER_CERTIFICATE_PASSWORD secret is not set"
          exit 1
        fi
        
        if [ -z "${{ secrets.APPLE_PROVISIONING_PROFILE }}" ]; then
          echo "‚ùå APPLE_PROVISIONING_PROFILE secret is not set"
          exit 1
        fi
        
        # Create certificate and provisioning profile
        echo "${{ secrets.APPLE_DEVELOPER_CERTIFICATE }}" | base64 --decode > /tmp/certificate.p12
        if [ ! -f /tmp/certificate.p12 ] || [ ! -s /tmp/certificate.p12 ]; then
          echo "‚ùå Failed to create certificate file or file is empty"
          exit 1
        fi
        
        echo "${{ secrets.APPLE_PROVISIONING_PROFILE }}" | base64 --decode > /tmp/profile.mobileprovision
        if [ ! -f /tmp/profile.mobileprovision ] || [ ! -s /tmp/profile.mobileprovision ]; then
          echo "‚ùå Failed to create provisioning profile file or file is empty"
          exit 1
        fi
        
        # Create keychain and import certificate
        security create-keychain -p "temp" build.keychain
        security default-keychain -s build.keychain
        security unlock-keychain -p "temp" build.keychain
        security set-keychain-settings -t 3600 -u build.keychain
        
        # Import certificate
        IMPORT_OUTPUT=$(security import /tmp/certificate.p12 -k build.keychain -P "${{ secrets.APPLE_DEVELOPER_CERTIFICATE_PASSWORD }}" -T /usr/bin/codesign 2>&1)
        IMPORT_EXIT_CODE=$?
        
        if [ $IMPORT_EXIT_CODE -ne 0 ]; then
          echo "‚ùå Failed to import certificate"
          exit 1
        fi
        
        security set-key-partition-list -S apple-tool:,apple: -s -k "temp" build.keychain
        
        # Install provisioning profile
        mkdir -p ~/Library/MobileDevice/Provisioning\ Profiles
        cp /tmp/profile.mobileprovision ~/Library/MobileDevice/Provisioning\ Profiles/
        
        # Verify the setup
        CERT_COUNT=$(security find-identity -v -p codesigning build.keychain | grep -c "valid identities found" || echo "0")
        PROFILE_COUNT=$(ls ~/Library/MobileDevice/Provisioning\ Profiles/*.mobileprovision 2>/dev/null | wc -l || echo "0")
        
        if [ "$CERT_COUNT" -eq 0 ]; then
          echo "‚ùå No valid certificates found - code signing setup failed"
          exit 1
        fi
        
        if [ "$PROFILE_COUNT" -eq 0 ]; then
          echo "‚ùå No provisioning profiles found - code signing setup failed"
          exit 1
        fi
        
        echo "‚úÖ Code signing configured for TestFlight"
        
    - name: Export IPA for TestFlight
      run: |
        echo "üì¶ Exporting IPA for TestFlight deployment"
        
        # Get the actual certificate name from the keychain
        echo "üîç Detecting certificate name..."
        CERT_NAME=$(security find-identity -v -p codesigning build.keychain | grep "iPhone Distribution" | head -1 | sed 's/.*"\(.*\)".*/\1/' || echo "")
        
        if [ -z "$CERT_NAME" ]; then
          echo "‚ö†Ô∏è No iPhone Distribution certificate found, trying alternative names..."
          CERT_NAME=$(security find-identity -v -p codesigning build.keychain | grep -E "(Distribution|Developer)" | head -1 | sed 's/.*"\(.*\)".*/\1/' || echo "")
        fi
        
        if [ -z "$CERT_NAME" ]; then
          echo "‚ö†Ô∏è No certificates found in build.keychain, trying system keychain..."
          CERT_NAME=$(security find-identity -v -p codesigning | grep "iPhone Distribution" | head -1 | sed 's/.*"\(.*\)".*/\1/' || echo "iPhone Distribution")
        fi
        
        echo "üìã Using certificate: $CERT_NAME"
        
        # Get the actual provisioning profile name
        echo "üîç Detecting provisioning profile name..."
        PROFILE_NAME=$(security cms -D -i ~/Library/MobileDevice/Provisioning\ Profiles/*.mobileprovision | grep -A1 "<key>Name</key>" | tail -1 | sed 's/.*<string>\(.*\)<\/string>.*/\1/' || echo "${{ secrets.APPLE_PROVISIONING_PROFILE_NAME }}")
        echo "üìã Using profile: $PROFILE_NAME"
        
        # Create ExportOptions.plist for TestFlight
        echo '<?xml version="1.0" encoding="UTF-8"?>' > ExportOptions.plist
        echo '<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">' >> ExportOptions.plist
        echo '<plist version="1.0">' >> ExportOptions.plist
        echo '<dict>' >> ExportOptions.plist
        echo '    <key>method</key>' >> ExportOptions.plist
        echo '    <string>app-store</string>' >> ExportOptions.plist
        echo '    <key>teamID</key>' >> ExportOptions.plist
        echo '    <string>${{ secrets.APPLE_TEAM_ID }}</string>' >> ExportOptions.plist
        echo '    <key>signingStyle</key>' >> ExportOptions.plist
        echo '    <string>manual</string>' >> ExportOptions.plist
        echo '    <key>provisioningProfiles</key>' >> ExportOptions.plist
        echo '    <dict>' >> ExportOptions.plist
        echo '        <key>com.cosmos.guras</key>' >> ExportOptions.plist
        echo "        <string>$PROFILE_NAME</string>" >> ExportOptions.plist
        echo '    </dict>' >> ExportOptions.plist
        echo '    <key>signingCertificate</key>' >> ExportOptions.plist
        echo "    <string>$CERT_NAME</string>" >> ExportOptions.plist
        echo '    <key>uploadBitcode</key>' >> ExportOptions.plist
        echo '    <false/>' >> ExportOptions.plist
        echo '    <key>uploadSymbols</key>' >> ExportOptions.plist
        echo '    <true/>' >> ExportOptions.plist
        echo '</dict>' >> ExportOptions.plist
        echo '</plist>' >> ExportOptions.plist
        
        # Debug: Show exportOptions.plist content
        echo "üìã ExportOptions.plist content:"
        cat ExportOptions.plist
        
        # Debug: Show the profile name being used
        echo "üìã Profile name from secret: ${{ secrets.APPLE_PROVISIONING_PROFILE_NAME }}"
        echo "üìã Detected profile name: $PROFILE_NAME"
        
        # Debug: Show bundle ID being used
        echo "üìã Bundle ID from Xcode project: com.cosmos.guras"
        
        # Debug: Show team ID being used
        echo "üìã Team ID from secret: ${{ secrets.APPLE_TEAM_ID }}"
        
        # Debug: List available certificates
        echo "üìã Available certificates:"
        security find-identity -v -p codesigning
        
        # Debug: List installed provisioning profiles with details
        echo "üìã Installed provisioning profiles:"
        for profile in ~/Library/MobileDevice/Provisioning\ Profiles/*.mobileprovision; do
            echo "Profile: $profile"
            security cms -D -i "$profile" | grep -E "(Name|TeamName|AppIDName|TeamIdentifier)" || echo "Could not read profile"
        done
        
        # Check if archive exists using workspace root path
        ARCHIVE_PATH="$GITHUB_WORKSPACE/artifacts/ios/build/Guras.xcarchive"
        if [ ! -d "$ARCHIVE_PATH" ]; then
          echo "‚ùå Archive not found at $ARCHIVE_PATH"
          echo "üìã Available files in artifacts:"
          find "$GITHUB_WORKSPACE/artifacts" -type f -name "*.xcarchive" || echo "No archives found"
          echo "üìã Looking for xcarchive directories:"
          find "$GITHUB_WORKSPACE/artifacts" -type d -name "*.xcarchive" || echo "No archive directories found"
          echo "üìã Artifacts directory structure:"
          find "$GITHUB_WORKSPACE/artifacts" -type f | head -20
          exit 1
        fi
        
        echo "‚úÖ Archive found at: $ARCHIVE_PATH"
        
        # Export IPA from archive with error handling
        echo "üì¶ Exporting IPA..."
        if ! xcodebuild -exportArchive -archivePath "$ARCHIVE_PATH" -exportPath ./build -exportOptionsPlist ExportOptions.plist; then
          echo "‚ùå Export failed"
          echo "üìã Checking export logs..."
          if [ -f "./build/ExportOptions.plist" ]; then
            echo "üìã ExportOptions.plist was created in build directory"
          fi
          if [ -d "./build" ]; then
            echo "üìã Build directory contents:"
            ls -la ./build/
          fi
          exit 1
        fi
        
        # Verify IPA was created
        if [ ! -f "./build/Guras.ipa" ]; then
          echo "‚ùå IPA file not found after export"
          echo "üìã Build directory contents:"
          ls -la ./build/
          exit 1
        fi
        
        echo "‚úÖ IPA exported successfully: ./build/Guras.ipa"
        echo "üìã IPA file size: $(ls -la ./build/Guras.ipa)"
        
        # Verify the bundle identifier in the IPA
        echo "üîç Verifying bundle identifier in IPA..."
        mkdir -p /tmp/ipa-extract
        unzip -q ./build/Guras.ipa -d /tmp/ipa-extract
        if [ -f "/tmp/ipa-extract/Payload/Guras.app/Info.plist" ]; then
          BUNDLE_ID=$(plutil -extract CFBundleIdentifier raw /tmp/ipa-extract/Payload/Guras.app/Info.plist)
          echo "üìã Bundle identifier in IPA: $BUNDLE_ID"
          if [ "$BUNDLE_ID" != "com.cosmos.guras" ]; then
            echo "‚ùå Bundle identifier mismatch! Expected: com.cosmos.guras, Found: $BUNDLE_ID"
            exit 1
          else
            echo "‚úÖ Bundle identifier matches expected value"
          fi
        else
          echo "‚ö†Ô∏è Could not extract bundle identifier from IPA"
        fi
        rm -rf /tmp/ipa-extract
        
    - name: Upload to TestFlight
      run: |
        echo "üì± Uploading to TestFlight..."
        echo "Version: ${{ needs.build.outputs.version }}"
        echo "IPA Path: ./build/Guras.ipa"
        echo "Bundle ID: com.cosmos.guras"
        
        # Check if IPA exists
        if [ ! -f "./build/Guras.ipa" ]; then
          echo "‚ùå IPA file not found at ./build/Guras.ipa"
          echo "üìã Current directory: $(pwd)"
          echo "üìã Build directory contents:"
          ls -la ./build/ || echo "Build directory not found"
          exit 1
        fi
        
        echo "‚úÖ IPA file found: $(ls -la ./build/Guras.ipa)"
        
        # Verify app exists in App Store Connect
        echo "üîç Verifying app exists in App Store Connect..."
        echo "üìã Bundle ID: com.cosmos.guras"
        echo "üìã Apple ID: ${{ secrets.APPLE_ID }}"
        echo "üìã Note: If this fails, you need to create the app in App Store Connect first"
        echo "üìã Go to: https://appstoreconnect.apple.com"
        echo "üìã Create a new iOS app with bundle ID: com.cosmos.guras"
        
        # Test Apple ID authentication and app access
        echo "üîê Testing Apple ID authentication..."
        if ! xcrun altool --list-providers -u "${{ secrets.APPLE_ID }}" -p "${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}" > /dev/null 2>&1; then
          echo "‚ùå Apple ID authentication failed"
          echo "üìã Please verify:"
          echo "   - APPLE_ID secret is correct"
          echo "   - APPLE_APP_SPECIFIC_PASSWORD secret is correct"
          echo "   - App-specific password is valid and not expired"
          exit 1
        else
          echo "‚úÖ Apple ID authentication successful"
        fi
        
        # Try to list apps to verify access
        echo "üì± Testing app access..."
        if ! xcrun altool --list-apps -u "${{ secrets.APPLE_ID }}" -p "${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}" 2>/dev/null | grep -q "com.cosmos.guras"; then
          echo "‚ö†Ô∏è App 'com.cosmos.guras' not found in your App Store Connect account"
          echo "üìã This could mean:"
          echo "   1. The app doesn't exist in App Store Connect"
          echo "   2. Your Apple ID doesn't have access to this app"
          echo "   3. The bundle identifier is different"
          echo "üìã Please create the app in App Store Connect first"
          echo "üìã Go to: https://appstoreconnect.apple.com"
          echo "üìã Create a new iOS app with bundle ID: com.cosmos.guras"
        else
          echo "‚úÖ App 'com.cosmos.guras' found in App Store Connect"
        fi
        
        # Upload to App Store Connect using xcrun altool
        xcrun altool --upload-app \
                     --type ios \
                     --file ./build/Guras.ipa \
                     --username "${{ secrets.APPLE_ID }}" \
                     --password "${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}" \
                     --verbose
        
        echo "‚úÖ IPA uploaded to TestFlight successfully"
        
    - name: TestFlight Deployment Summary
      run: |
        echo "üéâ ========================================="
        echo "‚úÖ TestFlight deployment completed successfully!"
        echo "üì¶ Version: ${{ needs.build.outputs.version }}"
        echo "üì± IPA: Uploaded to TestFlight"
        echo "üìù Note: Check App Store Connect for processing status"
        echo "üìã Note: Use workflow_dispatch with 'Deploy to App Store' checked for App Store deployment"
        echo "üéâ ========================================="

  deploy-appstore:
    name: Deploy to App Store
    runs-on: macos-latest
    needs: build
    if: success() && github.event_name == 'workflow_dispatch' && github.event.inputs.deploy_to_appstore == 'true'
    environment: production
    
    steps:        
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Download build artifacts
      uses: actions/download-artifact@v4
      with:
        name: ios-build-v${{ needs.build.outputs.version }}
        path: ./artifacts
        
    - name: Setup code signing
      run: |
        echo "üîê Setting up code signing for App Store deployment..."
        
        # Create keychain
        security create-keychain -p "" build.keychain
        security default-keychain -s build.keychain
        security unlock-keychain -p "" build.keychain
        security set-keychain-settings build.keychain
        
        # Import certificate
        echo "üìã Importing distribution certificate..."
        echo "${{ secrets.APPLE_DEVELOPER_CERTIFICATE }}" | base64 --decode > /tmp/certificate.p12
        
        # Check certificate file
        if [ ! -s /tmp/certificate.p12 ]; then
          echo "‚ùå Certificate file is empty or missing"
          exit 1
        fi
        
        # Import certificate into keychain
        security import /tmp/certificate.p12 -k build.keychain -P "${{ secrets.APPLE_DEVELOPER_CERTIFICATE_PASSWORD }}" -T /usr/bin/codesign
        security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "" build.keychain
        
        # Install provisioning profile
        echo "üìã Installing App Store provisioning profile..."
        echo "${{ secrets.APPLE_PROVISIONING_PROFILE }}" | base64 --decode > /tmp/profile.mobileprovision
        
        if [ ! -s /tmp/profile.mobileprovision ]; then
          echo "‚ùå Provisioning profile file is empty or missing"
          exit 1
        fi
        
        mkdir -p ~/Library/MobileDevice/Provisioning\ Profiles
        cp /tmp/profile.mobileprovision ~/Library/MobileDevice/Provisioning\ Profiles/
        
        # Get the actual profile name from the installed profile
        echo "üîç Detecting installed provisioning profile name..."
        PROFILE_NAME=$(security cms -D -i ~/Library/MobileDevice/Provisioning\ Profiles/*.mobileprovision | grep -A1 "<key>Name</key>" | tail -1 | sed 's/.*<string>\(.*\)<\/string>.*/\1/')
        
        if [ -z "$PROFILE_NAME" ]; then
          echo "‚ö†Ô∏è Could not detect profile name, using secret value..."
          PROFILE_NAME="${{ secrets.APPLE_PROVISIONING_PROFILE_NAME }}"
        fi
        
        echo "üìã Detected profile name: $PROFILE_NAME"
        
        # Verify certificate and profile
        echo "üîç Verifying code signing setup..."
        security find-identity -v -p codesigning build.keychain
        
        echo "‚úÖ Code signing setup completed"
        
    - name: Export IPA for App Store
      run: |
        echo "üì¶ Exporting IPA for App Store deployment..."
        
        # Set up environment
        export DEVELOPER_DIR="/Applications/Xcode_16.2.app/Contents/Developer"
        export PATH="$DEVELOPER_DIR/usr/bin:/usr/bin:/bin:/usr/sbin:/sbin"
        
        # Use the same build number from the original build
        BUILD_NUMBER="${{ needs.build.outputs.build_number }}"
        echo "üìã Using build number: $BUILD_NUMBER"
        
        # Detect certificate name
        CERT_NAME=$(security find-identity -v -p codesigning build.keychain | grep "Apple Distribution" | head -1 | sed 's/.*"\(.*\)".*/\1/')
        
        if [ -z "$CERT_NAME" ]; then
          echo "‚ö†Ô∏è No Apple Distribution certificate found, trying alternative names..."
          CERT_NAME=$(security find-identity -v -p codesigning build.keychain | grep "Distribution" | head -1 | sed 's/.*"\(.*\)".*/\1/')
        fi
        
        if [ -z "$CERT_NAME" ]; then
          echo "‚ùå No distribution certificate found"
          security find-identity -v -p codesigning build.keychain
          exit 1
        fi
        
        echo "üìã Using certificate: $CERT_NAME"
        
        # Get the actual provisioning profile name from the installed profile
        echo "üîç Detecting provisioning profile name..."
        PROFILE_NAME=$(security cms -D -i ~/Library/MobileDevice/Provisioning\ Profiles/*.mobileprovision | grep -A1 "<key>Name</key>" | tail -1 | sed 's/.*<string>\(.*\)<\/string>.*/\1/')
        
        if [ -z "$PROFILE_NAME" ]; then
          echo "‚ö†Ô∏è Could not detect profile name, using secret value..."
          PROFILE_NAME="${{ secrets.APPLE_PROVISIONING_PROFILE_NAME }}"
        fi
        
        echo "üìã Using profile: $PROFILE_NAME"
        
        # Debug: List all installed profiles
        echo "üìã All installed provisioning profiles:"
        for profile in ~/Library/MobileDevice/Provisioning\ Profiles/*.mobileprovision; do
            if [ -f "$profile" ]; then
                echo "Profile: $profile"
                security cms -D -i "$profile" | grep -E "(Name|TeamName|AppIDName|TeamIdentifier)" || echo "Could not read profile"
            fi
        done
        
        # Create ExportOptions.plist for App Store
        echo "üìã Creating ExportOptions.plist for App Store..."
        echo '<?xml version="1.0" encoding="UTF-8"?>' > ExportOptions.plist
        echo '<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">' >> ExportOptions.plist
        echo '<plist version="1.0">' >> ExportOptions.plist
        echo '<dict>' >> ExportOptions.plist
        echo '    <key>method</key>' >> ExportOptions.plist
        echo '    <string>app-store</string>' >> ExportOptions.plist
        echo '    <key>teamID</key>' >> ExportOptions.plist
        echo "    <string>${{ secrets.APPLE_TEAM_ID }}</string>" >> ExportOptions.plist
        echo '    <key>signingStyle</key>' >> ExportOptions.plist
        echo '    <string>manual</string>' >> ExportOptions.plist
        echo '    <key>provisioningProfiles</key>' >> ExportOptions.plist
        echo '    <dict>' >> ExportOptions.plist
        echo '        <key>com.cosmos.guras</key>' >> ExportOptions.plist
        echo "        <string>$PROFILE_NAME</string>" >> ExportOptions.plist
        echo '    </dict>' >> ExportOptions.plist
        echo '    <key>signingCertificate</key>' >> ExportOptions.plist
        echo "    <string>$CERT_NAME</string>" >> ExportOptions.plist
        echo '    <key>uploadBitcode</key>' >> ExportOptions.plist
        echo '    <false/>' >> ExportOptions.plist
        echo '    <key>uploadSymbols</key>' >> ExportOptions.plist
        echo '    <true/>' >> ExportOptions.plist
        echo '</dict>' >> ExportOptions.plist
        echo '</plist>' >> ExportOptions.plist
        
        echo "üìã ExportOptions.plist content:"
        cat ExportOptions.plist
        
        # Find the archive
        ARCHIVE_PATH="$GITHUB_WORKSPACE/artifacts/ios/build/Guras.xcarchive"
        if [ ! -d "$ARCHIVE_PATH" ]; then
          echo "‚ùå Archive not found at $ARCHIVE_PATH"
          find "$GITHUB_WORKSPACE/artifacts" -type d -name "*.xcarchive" || echo "No archives found"
          exit 1
        fi
        
        echo "‚úÖ Archive found at: $ARCHIVE_PATH"
        
        # Export IPA
        echo "üì¶ Exporting IPA for App Store..."
        xcodebuild -exportArchive \
                   -archivePath "$ARCHIVE_PATH" \
                   -exportPath ./build \
                   -exportOptionsPlist ExportOptions.plist
        
        if [ ! -f "./build/Guras.ipa" ]; then
          echo "‚ùå IPA export failed"
          ls -la ./build/ || echo "Build directory not found"
          exit 1
        fi
        
        echo "‚úÖ IPA exported successfully: ./build/Guras.ipa"
        echo "üìã IPA file size: $(ls -la ./build/Guras.ipa)"
        
    - name: Upload to App Store Connect
      run: |
        echo "üè™ Uploading to App Store Connect for review..."
        echo "Version: ${{ needs.build.outputs.version }}"
        echo "IPA Path: ./build/Guras.ipa"
        
        # Verify IPA exists
        if [ ! -f "./build/Guras.ipa" ]; then
          echo "‚ùå IPA file not found"
          exit 1
        fi
        
        echo "‚úÖ IPA file found: $(ls -la ./build/Guras.ipa)"
        
        # Verify app exists in App Store Connect
        echo "üîç Verifying app exists in App Store Connect..."
        if ! xcrun altool --list-apps -u "${{ secrets.APPLE_ID }}" -p "${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}" 2>/dev/null | grep -q "com.cosmos.guras"; then
          echo "‚ùå App 'com.cosmos.guras' not found in App Store Connect"
          echo "üìã Please ensure the app exists in App Store Connect"
          exit 1
        fi
        
        echo "‚úÖ App found in App Store Connect"
        
        # Upload to App Store Connect
        echo "üì§ Uploading to App Store Connect..."
        xcrun altool --upload-app \
                     --type ios \
                     --file ./build/Guras.ipa \
                     --username "${{ secrets.APPLE_ID }}" \
                     --password "${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}" \
                     --verbose
        
        if [ $? -eq 0 ]; then
          echo "‚úÖ App uploaded to App Store Connect successfully"
          echo "üìù Next steps:"
          echo "   1. Go to App Store Connect: https://appstoreconnect.apple.com"
          echo "   2. Navigate to your app"
          echo "   3. Go to 'TestFlight' tab to see the uploaded build"
          echo "   4. Submit for App Store review when ready"
        else
          echo "‚ùå Upload failed"
          exit 1
        fi
        
    - name: App Store Deployment Summary
      run: |
        echo "üéâ ========================================="
        echo "‚úÖ App Store deployment completed successfully!"
        echo "üì¶ Version: ${{ needs.build.outputs.version }}"
        echo "üì± IPA: Uploaded to App Store Connect"
        echo "üìù Status: Ready for App Store review"
        echo "üîó Next: Submit for review in App Store Connect"
        echo "üìã Note: Same build used for both TestFlight and App Store"
        echo "üéâ =========================================" 